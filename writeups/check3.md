## 0. 小作文
类似于checkpoint2, checkpoint3实现了TCP的部分功能, checkpoint3中实现了TCP的发送端, 代码量不大但是要花很多耐心debug, 每次都需要接近一分钟的编译+测试相当痛苦, 由于使用测试工具, 定位bug的位置也相当难受(主要是不会用gdb), 只能采用最老土的方法————日志. 另一个比较痛苦的点在于没法直接用iostream来输出信息到控制台, 只能退而求其次使用fstream写到文件里去, 所以我的代码以及部分TCPSender测试中包含了`fstream`头文件. 推荐在debug的过程中翻看tests下的测试文件, 以及sender_test_harness.hh, 可以看到一些和测试相关的信息, 并理解测试用例期望的结果是怎样得到的.

## 1. 过一遍文档

### 1.1. 我们要实现的TCPSender主要的工作
- 追踪TCP通信接收端的窗口大小: 很显然, 我们需要知道接收方的窗口大小才能确定合适的发包大小
- 发送端从输入字节流中读取数据, 在不超过当前已知窗口大小的情况下尽可能组装成大的TCP数据段(有必要的话需要包含SYN与FIN信号), 并将该TCP段发送出去. 当且仅当窗口已满或输入端字节流清空, TCPSender不必发送TCP数据段
- 缓存处于传输过程中的包(即已发送而未收到接收端确认信号的包): 用于实现TCP的超时重传机制 (P.S. 文档里把这个包叫做outstanding segments, 我才知道原来outstanding还有待解决的意思)
- 一定时间后未被确认的已发送包需要进行超时重传: TCP是个负责任的协议, 它必须确认包的完整接收, 所以需要重传避免一些网络问题引起的丢包或错包或者别的什么问题

原文档还解释了为什么需要重传以及为什么重传不影响接收端正常接收数据段, 总结一下就是TCP是个安全有序的传输协议, 它需要每个包都被确认收到, 以此来维护它的安全性, 而在checkpoint2中我们已经完成了TCP接收端的数据有序化工作, 所以很显然重传并不会影响TCP传输数据的有序性

### 1.2.TCPSender如何知道一个数据段是否丢失
在Lab中我们通过实现tick()方法来进行计时并确认已发送包是否超时. tick()方法会告知TCPSender距离上一次调用tick()经过了多长时间, tick()方法会从外部隔一段时间调用一次, 在每次调用时都会判断第一个未确认包是否超时, 超时则重传

一些细节:
1. 每过几毫秒tick方法会被调用, 并通过参数传递的形式告知经过的时长. 需要注意的是, tick(args..)内部不应该调用任何获取系统时间的函数, tick的计时与系统时间没有任何联系
2. TCPSender的构造函数中, 存在一个参数用于初始化初始超时重传阈值(RTO, retransmission timeout) 已发送而未被确认的包经过大于等于RTO的时间后会进行重传
3. 我们要实现一个timer: 一个可以在任意时间点启动, 并且在到达RTO时超时的"闹钟". 文档再次强调了"不要用现实时间"
4. 在每一个非0长数据段发送时, 如果timer没有启动, 那么启动timer.
5. 当所有已发送的包都被确认时, 停止timer
6. LAB要求我们实现一种非常简单粗暴的流量控制算法, 在tick调用后发现超时会启动, 以下是算法具体步骤:
    - 重传最早发送且未得到完整确认的包
    - 如果接收端窗口大小不为0:
        1. 记录连续重传次数
        2. 实施RTO的"指数退避", 人话就是RTO翻倍, 但需要注意这个翻倍是临时的, 一旦重传的包被ack, RTO要恢复到最初的值
    - RTO指数退避后需要重置计时器计数
7. 收到ackno, 并且可以确认第一个未被ack的包已经被完整确认收到, 那么需要进行以下几个操作:
    - 重置RTO的值
    - 如果还有未被确认的包, 重置计时器, 为下一个未确认包进行超时计时
    - 重置重传计数器

计时器的实现可以直接在TCPSender类内直接实现, 当然你也可以为计时器设计一个单独的类, 我个人推荐后者, 代码功能更清晰

### 1.3. TCPSender要实现的主要函数
1. void push( const TransmitFunction& transmit );

TransmitFunction类似于别名, 本质上其实就是`std::function`, 在tcp_sender.hh中的具体声明代码
```C++
using TransmitFunction = std::function<void( const TCPSenderMessage& )>;
```
如果好奇传入的transmit干了什么, 可以查看`tests/sender_test_harness.hh`的代码.

push函数的工作简单来说就是从内部字节流中读取数据并组装成报文, 然后把它发送出去. 需要注意的是, 报文应该尽量填满当前窗口大小, 即报文长度应该尽可能的大. 但需要记得, 报文长度不该超过TCP标准规定的最大报文长度, 在lab中它是`TCPConfig::MAX_PAYLOAD_SIZE`(TCPConfig的定义在`/util/tcp_config.hh`).

在实现的过程中, 需考虑一个问题, 接收端的窗口大小只在收到来自发送端的包的时候才会被动的告知发送端, 所以如果在窗口为0时仍然按照上述逻辑处理push函数, 那么一旦接收端窗口被填满, 并将这个消息传给发送端, 那么发送端永远都不会再向接收端发送消息了. 
因此, 在已知接收端窗口大小为0时, 发送端需要假装窗口大小不为0, 照常发送消息, 直到收到接收端的回复, 更新窗口大小

2. void receive( const TCPReceiverMessage& msg );
模拟发送端接收来自接收端的回复, 在这里需要进行的操作包括:
    - 判断是否有包被完全确认
    - 更新未确认包队列
    - 更新超时重传计时器

3. void tick( uint64_t ms_since_last_tick, const TransmitFunction& transmit);
模拟时间流动, ms_since_last_tick存储距离上一次调用tick函数经过的时间
需要在这里进行超时重传 (如果超时)

4. TCPSenderMessage make_empty_message() const;
制造空消息, 注意empty_message发送后不需要进行重传, 也不会被当作一个需要被ack的消息

